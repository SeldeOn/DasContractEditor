function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _wrapRegExp() { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, void 0, groups); }; var _super = RegExp.prototype, _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = new RegExp(re, flags); return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype); } function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { return groups[name] = result[g[name]], groups; }, Object.create(null)); } return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); return result && (result.groups = buildGroups(result, this)), result; }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if ("string" == typeof substitution) { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } if ("function" == typeof substitution) { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = arguments; return "object" != _typeof(args[args.length - 1]) && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args); }); } return _super[Symbol.replace].call(this, str, substitution); }, _wrapRegExp.apply(this, arguments); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

import { keys } from 'min-dash';
export var operators = {
  equals: '=',
  less: '<',
  lessEquals: '<=',
  greater: '>',
  greaterEquals: '>='
};

function getOperatorName(string) {
  return keys(operators).filter(function (key) {
    return string === operators[key];
  })[0];
}

export function parseDuration(text) {
  if (!text || isEmptyString(text.trim())) {
    return {
      type: 'comparison',
      values: []
    };
  }

  var parsedComparison = parseComparison(text);

  if (parsedComparison) {
    return parsedComparison;
  }

  var parsedRange = parseRange(text);

  if (parsedRange) {
    return parsedRange;
  }
}
export function isEmptyString(string) {
  return string === '';
}
export function getComparisonString(comparisonOperator, comparisonValue) {
  if (comparisonOperator === 'equals') {
    return "duration(\"".concat(comparisonValue, "\")");
  } else {
    return "".concat(operators[comparisonOperator], " duration(\"").concat(comparisonValue, "\")");
  }
}
export function getRangeString(rangeStartValue, rangeEndValue, rangeStartType, rangeEndType) {
  var rangeStartChar = rangeStartType === 'exclude' ? ']' : '[',
      rangeEndChar = rangeEndType === 'exclude' ? '[' : ']';
  return "".concat(rangeStartChar, "duration(\"").concat(rangeStartValue, "\")") + "..duration(\"".concat(rangeEndValue, "\")").concat(rangeEndChar);
}
export function validateDuration(type, value) {
  if (type === 'yearMonthDuration') {
    return validateYearMonthDuration(value);
  } else if (type === 'dayTimeDuration') {
    return validateDayTimeDuration(value);
  }
}

function validateYearMonthDuration(value) {
  return /^P(\d+Y\d+M|\d+Y|\d+M)$/.test(value);
}

function validateDayTimeDuration(value) {
  return /^P(\d+DT\d+H|\d+D|T\d+H)$/.test(value);
}

export function withoutDurationCall(text) {
  var result = /^duration\("([^"]*)"\)$/.exec(text);
  return result && result[1];
}

function parseComparison(text) {
  var exactValue = withoutDurationCall(text);

  if (exactValue) {
    return {
      type: 'comparison',
      operator: 'equals',
      values: [exactValue]
    };
  }

  var _match = match( /*#__PURE__*/_wrapRegExp(/^(=|(:?<|>)=?)[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*duration\("((?:(?!")[\s\S])*)"\)$/, {
    operator: 1,
    value: 3
  }), text),
      operator = _match.operator,
      value = _match.value;

  if (operator && value) {
    return {
      type: 'comparison',
      values: [value],
      operator: getOperatorName(operator)
    };
  }
}

function parseRange(text) {
  var _match2 = match( /*#__PURE__*/_wrapRegExp(/^([\[\]])duration\("((?:(?!")[\s\S])*)"\)\.\.duration\("((?:(?!")[\s\S])*)"\)([\[\]])$/, {
    start: 1,
    firstValue: 2,
    secondValue: 3,
    end: 4
  }), text),
      start = _match2.start,
      end = _match2.end,
      firstValue = _match2.firstValue,
      secondValue = _match2.secondValue;

  if (start && end) {
    return {
      type: 'range',
      values: [firstValue, secondValue],
      start: start === ']' ? 'exclude' : 'include',
      end: end === '[' ? 'exclude' : 'include'
    };
  }
}

function match(regex, input) {
  var _ref = regex.exec(input) || {
    groups: {}
  },
      groups = _ref.groups;

  return groups;
}
//# sourceMappingURL=Utils.js.map