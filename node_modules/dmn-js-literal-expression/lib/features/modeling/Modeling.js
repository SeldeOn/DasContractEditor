function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

import { forEach } from 'min-dash';
import UpdatePropertiesHandler from 'dmn-js-shared/lib/features/modeling/cmd/UpdatePropertiesHandler';

var Modeling = /*#__PURE__*/function () {
  function Modeling(commandStack, viewer, eventBus) {
    var _this = this;

    _classCallCheck(this, Modeling);

    this._commandStack = commandStack;
    this._viewer = viewer;
    this._eventBus = eventBus;
    eventBus.on('viewer.init', function () {
      // register modeling handlers
      registerHandlers(_this.getHandlers(), commandStack);
    });
  }

  _createClass(Modeling, [{
    key: "getHandlers",
    value: function getHandlers() {
      return Modeling._getHandlers();
    }
  }, {
    key: "getDecision",
    value: function getDecision() {
      return this._viewer.getDecision();
    }
  }, {
    key: "editDecisionName",
    value: function editDecisionName(name) {
      var decision = this.getDecision();
      var context = {
        element: decision,
        properties: {
          name: name
        }
      };

      this._commandStack.execute('element.updateProperties', context);
    }
  }, {
    key: "editDecisionId",
    value: function editDecisionId(id) {
      var decision = this.getDecision();
      var context = {
        element: decision,
        properties: {
          id: id
        }
      };

      this._commandStack.execute('element.updateProperties', context);
    }
  }, {
    key: "editLiteralExpressionText",
    value: function editLiteralExpressionText(text) {
      var decision = this.getDecision(),
          literalExpression = decision.decisionLogic;
      var context = {
        element: literalExpression,
        properties: {
          text: text
        }
      };

      this._commandStack.execute('element.updateProperties', context);
    }
  }, {
    key: "editExpressionLanguage",
    value: function editExpressionLanguage(expressionLanguage) {
      var decision = this.getDecision(),
          literalExpression = decision.decisionLogic;
      var context = {
        element: literalExpression,
        properties: {
          expressionLanguage: expressionLanguage
        }
      };

      this._commandStack.execute('element.updateProperties', context);
    }
  }, {
    key: "editVariableName",
    value: function editVariableName(name) {
      var decision = this.getDecision(),
          variable = decision.variable;
      var context = {
        element: variable,
        properties: {
          name: name
        }
      };

      this._commandStack.execute('element.updateProperties', context);
    }
  }, {
    key: "editVariableType",
    value: function editVariableType(typeRef) {
      var decision = this.getDecision(),
          variable = decision.variable;
      var context = {
        element: variable,
        properties: {
          typeRef: typeRef
        }
      };

      this._commandStack.execute('element.updateProperties', context);
    }
  }], [{
    key: "_getHandlers",
    value: function _getHandlers() {
      return {
        'element.updateProperties': UpdatePropertiesHandler
      };
    }
  }]);

  return Modeling;
}();

export { Modeling as default };
Modeling.$inject = ['commandStack', 'viewer', 'eventBus']; // helpers //////////////////////

/**
 * Register handlers with the command stack
 *
 * @param {Object} handlers { id -> Handler } map
 * @param {CommandStack} commandStack
 */

function registerHandlers(handlers, commandStack) {
  forEach(handlers, function (handler, id) {
    commandStack.registerHandler(id, handler);
  });
}
//# sourceMappingURL=Modeling.js.map