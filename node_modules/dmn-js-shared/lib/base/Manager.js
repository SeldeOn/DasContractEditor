function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import EventBus from 'diagram-js/lib/core/EventBus';
import DmnModdle from 'dmn-moddle';
import { domify, query as domQuery, remove as domRemove } from 'min-dom';
import { assign, debounce, every, find, isDefined, isFunction, isNumber } from 'min-dash';
import { wrapForCompatibility } from '../util/CompatibilityUtils';
/**
 * @typedef {import('./View').OpenResult} OpenResult
 */

/**
 * @typedef {import('./View').OpenError} OpenError
 */

var DEFAULT_CONTAINER_OPTIONS = {
  width: '100%',
  height: '100%',
  position: 'relative'
};
/**
 * The base class for DMN viewers and editors.
 *
 * @abstract
 */

var Manager = /*#__PURE__*/function () {
  /**
   * Create a new instance with the given options.
   *
   * @param  {Object} options
   *
   * @return {Manager}
   */
  function Manager() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Manager);

    _defineProperty(this, "_viewsChanged", function () {
      _this._emit('views.changed', {
        views: _this._views,
        activeView: _this._activeView
      });
    });

    this._eventBus = new EventBus();
    this._viewsChanged = debounce(this._viewsChanged, 0);
    this._views = [];
    this._viewers = {}; // keep support for callbacks

    this.open = wrapForCompatibility(this.open.bind(this));
    this.importXML = wrapForCompatibility(this.importXML.bind(this));
    this.saveXML = wrapForCompatibility(this.saveXML.bind(this));

    this._init(options);
  }
  /**
  * The importXML result.
  *
  * @typedef {Object} ImportXMLResult
  *
  * @property {Array<string>} warnings
  */

  /**
  * The importXML error.
  *
  * @typedef {Error} ImportXMLError
  *
  * @property {Array<string>} warnings
  */

  /**
   * Parse and render a DMN diagram.
   *
   * Once finished the viewer reports back the result to the
   * provided callback function with (err, warnings).
   *
   * ## Life-Cycle Events
   *
   * During import the viewer will fire life-cycle events:
   *
   *   * import.parse.start (about to read model from xml)
   *   * import.parse.complete (model read; may have worked or not)
   *   * import.render.start (graphical import start)
   *   * import.render.complete (graphical import finished)
   *   * import.done (everything done)
   *
   * You can use these events to hook into the life-cycle.
   *
   * @param {string} xml the DMN xml
   * @param {Object} [options]
   * @param {boolean} [options.open=true]
   *
   * @return {Promise<ImportXMLResult, ImportXMLError>}
   */


  _createClass(Manager, [{
    key: "importXML",
    value: function importXML(xml, options) {
      var self = this;
      options = options || {
        open: true
      };
      return new Promise(function (resolve, reject) {
        // hook in pre-parse listeners +
        // allow xml manipulation
        xml = self._emit('import.parse.start', {
          xml: xml
        }) || xml;
        var parseWarnings;

        self._moddle.fromXML(xml, 'dmn:Definitions').then(function (parseResult) {
          var definitions = parseResult.rootElement;
          var references = parseResult.references;
          var elementsById = parseResult.elementsById;
          parseWarnings = parseResult.warnings; // hook in post parse listeners +
          // allow definitions manipulation

          definitions = self._emit('import.parse.complete', ParseCompleteEvent({
            error: null,
            definitions: definitions,
            elementsById: elementsById,
            references: references,
            warnings: parseWarnings
          })) || definitions;

          self._setDefinitions(definitions);

          if (!options.open) {
            self._emit('import.done', {
              error: null,
              warnings: parseWarnings
            });

            resolve({
              warnings: parseWarnings
            });
            return;
          }

          var view = self._activeView || self._getInitialView(self._views);

          if (!view) {
            var noDisplayableContentsErr = new Error('no displayable contents');

            self._emit('import.done', {
              error: noDisplayableContentsErr,
              warnings: parseWarnings
            });

            noDisplayableContentsErr.warnings = parseWarnings;
            return reject(noDisplayableContentsErr);
          }

          self.open(view).then(function (result) {
            return {
              warnings: result.warnings
            };
          })["catch"](function (error) {
            return {
              error: error,
              warnings: error.warnings
            };
          }).then(function (result) {
            var allWarnings = [].concat(parseWarnings, result.warnings);

            self._emit('import.done', {
              error: result.error,
              warnings: allWarnings
            });

            if (result.error) {
              result.error.warnings = allWarnings;
              reject(result.error);
            } else {
              resolve({
                warnings: allWarnings
              });
            }
          });
        })["catch"](function (parseError) {
          parseWarnings = parseError.warnings;
          parseError = checkDMNCompatibilityError(parseError, xml) || checkValidationError(parseError) || parseError;

          self._emit('import.parse.complete', ParseCompleteEvent({
            error: parseError,
            warnings: parseWarnings
          }));

          self._emit('import.done', {
            error: parseError,
            warnings: parseWarnings
          });

          parseError.warnings = parseWarnings;
          return reject(parseError);
        });
      }); // TODO: remove with future dmn-js version

      function ParseCompleteEvent(data) {
        var event = self._eventBus.createEvent(data);

        Object.defineProperty(event, 'context', {
          enumerable: true,
          get: function get() {
            console.warn(new Error('import.parse.complete <context> is deprecated ' + 'and will be removed in future library versions'));
            return {
              warnings: data.warnings,
              references: data.references,
              elementsById: data.elementsById
            };
          }
        });
        return event;
      }
    }
  }, {
    key: "getDefinitions",
    value: function getDefinitions() {
      return this._definitions;
    }
    /**
     * Return active view.
     *
     * @return {View}
     */

  }, {
    key: "getActiveView",
    value: function getActiveView() {
      return this._activeView;
    }
    /**
     * Get the currently active viewer instance.
     *
     * @return {View}
     */

  }, {
    key: "getActiveViewer",
    value: function getActiveViewer() {
      var activeView = this.getActiveView();
      return activeView && this._getViewer(activeView);
    }
  }, {
    key: "getView",
    value: function getView(element) {
      return this._views.filter(function (v) {
        return v.element === element;
      })[0];
    }
  }, {
    key: "getViews",
    value: function getViews() {
      return this._views;
    }
    /**
     * The saveXML result.
     *
     * @typedef {Object} SaveXMLResult
     *
     * @property {string} xml
     */

    /**
     * Export the currently displayed DMN diagram as
     * a DMN XML document.
     *
     * ## Life-Cycle Events
     *
     * During XML saving the viewer will fire life-cycle events:
     *
     *   * saveXML.start (before serialization)
     *   * saveXML.serialized (after xml generation)
     *   * saveXML.done (everything done)
     *
     * You can use these events to hook into the life-cycle.
     *
     * @param {Object} [options] export options
     * @param {boolean} [options.format=false] output formated XML
     * @param {boolean} [options.preamble=true] output preamble
     *
     * @return {Promise<SaveXMLResult, Error>}
     */

  }, {
    key: "saveXML",
    value: function saveXML(options) {
      var self = this;
      options = options || {};
      var definitions = this._definitions;
      return new Promise(function (resolve, reject) {
        if (!definitions) {
          reject(new Error('no definitions loaded'));
          return;
        } // allow to fiddle around with definitions


        definitions = self._emit('saveXML.start', {
          definitions: definitions
        }) || definitions;

        self._moddle.toXML(definitions, options).then(function (result) {
          var xml = result.xml;
          xml = self._emit('saveXML.serialized', {
            xml: xml
          }) || xml;
          return {
            xml: xml
          };
        })["catch"](function (error) {
          return {
            error: error
          };
        }).then(function (result) {
          self._emit('saveXML.done', result);

          if (result.error) {
            reject(result.error);
          } else {
            resolve({
              xml: result.xml
            });
          }
        });
      });
    }
    /**
     * Register an event listener
     *
     * Remove a previously added listener via {@link #off(event, callback)}.
     *
     * @param {string} event
     * @param {number} [priority]
     * @param {Function} callback
     * @param {Object} [that]
     */

  }, {
    key: "on",
    value: function on() {
      var _this$_eventBus;

      (_this$_eventBus = this._eventBus).on.apply(_this$_eventBus, arguments);
    }
    /**
     * De-register an event listener
     *
     * @param {string} event
     * @param {Function} callback
     */

  }, {
    key: "off",
    value: function off() {
      var _this$_eventBus2;

      (_this$_eventBus2 = this._eventBus).off.apply(_this$_eventBus2, arguments);
    }
    /**
     * Register a listener to be invoked once only.
     *
     * @param {string} event
     * @param {number} [priority]
     * @param {Function} callback
     * @param {Object} [that]
     */

  }, {
    key: "once",
    value: function once() {
      var _this$_eventBus3;

      (_this$_eventBus3 = this._eventBus).once.apply(_this$_eventBus3, arguments);
    }
  }, {
    key: "attachTo",
    value: function attachTo(parentNode) {
      // unwrap jQuery if provided
      if (parentNode.get && parentNode.constructor.prototype.jquery) {
        parentNode = parentNode.get(0);
      }

      if (typeof parentNode === 'string') {
        parentNode = domQuery(parentNode);
      }

      parentNode.appendChild(this._container);

      this._emit('attach', {});
    }
  }, {
    key: "detach",
    value: function detach() {
      this._emit('detach', {});

      domRemove(this._container);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      Object.keys(this._viewers).forEach(function (viewerId) {
        var viewer = _this2._viewers[viewerId];
        safeExecute(viewer, 'destroy');
      });
      domRemove(this._container);
    }
  }, {
    key: "_init",
    value: function _init(options) {
      this._options = options;
      this._moddle = this._createModdle(options);
      this._viewers = {};
      this._views = [];
      var container = domify('<div class="dmn-js-parent"></div>');
      var containerOptions = assign({}, DEFAULT_CONTAINER_OPTIONS, options);
      assign(container.style, {
        width: ensureUnit(containerOptions.width),
        height: ensureUnit(containerOptions.height),
        position: containerOptions.position
      });
      this._container = container;

      if (options.container) {
        this.attachTo(options.container);
      }
    }
    /**
     * Open diagram view.
     *
     * @param  {View} view
     * @returns {Promise} Resolves with {OpenResult} when successful
     * or rejects with {OpenError}
     */

  }, {
    key: "open",
    value: function open(view) {
      return this._switchView(view);
    }
  }, {
    key: "_setDefinitions",
    value: function _setDefinitions(definitions) {
      this._definitions = definitions;

      this._updateViews();
    }
  }, {
    key: "_updateViews",
    value:
    /**
     * Recompute changed views after elements in
     * the DMN diagram have changed.
     */
    function _updateViews() {
      var definitions = this._definitions;

      if (!definitions) {
        this._views = [];

        this._switchView(null);

        return;
      }

      var viewProviders = this._getViewProviders();

      var displayableElements = [definitions].concat(_toConsumableArray(definitions.drgElement || [])); // compute list of available views

      var views = this._views,
          newViews = [];

      var _iterator = _createForOfIteratorHelper(displayableElements),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var element = _step.value;
          var provider = find(viewProviders, function (provider) {
            if (typeof provider.opens === 'string') {
              return provider.opens === element.$type;
            } else {
              return provider.opens(element);
            }
          });

          if (!provider) {
            continue;
          }

          var view = {
            element: element,
            id: element.id,
            name: element.name,
            type: provider.id
          };
          newViews.push(view);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var activeView = this._activeView,
          newActiveView;

      if (activeView) {
        // check the new active view
        newActiveView = find(newViews, function (view) {
          return viewsEqual(activeView, view);
        }) || this._getInitialView(newViews);

        if (!newActiveView) {
          this._switchView(null);

          return;
        }
      } // Views have changed if
      // active view has changed OR
      // number of views has changed OR
      // not all views equal


      var activeViewChanged = !viewsEqual(activeView, newActiveView) || viewNameChanged(activeView, newActiveView);
      var viewsChanged = views.length !== newViews.length || !every(newViews, function (newView) {
        return find(views, function (view) {
          return viewsEqual(view, newView) && !viewNameChanged(view, newView);
        });
      });
      this._activeView = newActiveView;
      this._views = newViews;

      if (activeViewChanged || viewsChanged) {
        this._viewsChanged();
      }
    }
  }, {
    key: "_getInitialView",
    value: function _getInitialView(views) {
      return views[0];
    }
    /**
     * Switch to another view.
     *
     * @param  {View} newView
     * @returns {Promise} Resolves with {OpenResult} when successful
     * or rejects with {OpenError}
     */

  }, {
    key: "_switchView",
    value: function _switchView(newView) {
      var self = this;
      return new Promise(function (resolve, reject) {
        var complete = function complete(openError, openResult) {
          self._viewsChanged();

          if (openError) {
            reject(openError);
          } else {
            resolve(openResult);
          }
        };

        var activeView = self.getActiveView(),
            activeViewer;

        var newViewer = newView && self._getViewer(newView),
            element = newView && newView.element;

        if (activeView) {
          activeViewer = self._getViewer(activeView);

          if (activeViewer !== newViewer) {
            safeExecute(activeViewer, 'clear');
            activeViewer.detach();
          }
        }

        self._activeView = newView;

        if (newViewer) {
          if (activeViewer !== newViewer) {
            newViewer.attachTo(self._container);
          }

          self._emit('import.render.start', {
            view: newView,
            element: element
          });

          newViewer.open(element).then(function (result) {
            self._emit('import.render.complete', {
              view: newView,
              error: null,
              warnings: result.warnings
            });

            complete(null, result);
          })["catch"](function (error) {
            self._emit('import.render.complete', {
              view: newView,
              error: error,
              warnings: error.warnings
            });

            complete(error, null);
          });
          return;
        } // no active view


        complete();
      });
    }
  }, {
    key: "_getViewer",
    value: function _getViewer(view) {
      var type = view.type;
      var viewer = this._viewers[type];

      if (!viewer) {
        viewer = this._viewers[type] = this._createViewer(view.type);

        this._emit('viewer.created', {
          type: type,
          viewer: viewer
        });
      }

      return viewer;
    }
  }, {
    key: "_createViewer",
    value: function _createViewer(id) {
      var provider = find(this._getViewProviders(), function (provider) {
        return provider.id === id;
      });

      if (!provider) {
        throw new Error('no provider for view type <' + id + '>');
      }

      var Viewer = provider.constructor;
      var providerOptions = this._options[id] || {};
      var commonOptions = this._options.common || {};
      return new Viewer(_objectSpread(_objectSpread(_objectSpread({}, commonOptions), providerOptions), {}, {
        additionalModules: [].concat(_toConsumableArray(providerOptions.additionalModules || []), [{
          _parent: ['value', this],
          moddle: ['value', this._moddle]
        }])
      }));
    }
    /**
     * Emit an event.
     */

  }, {
    key: "_emit",
    value: function _emit() {
      var _this$_eventBus4;

      return (_this$_eventBus4 = this._eventBus).fire.apply(_this$_eventBus4, arguments);
    }
  }, {
    key: "_createModdle",
    value: function _createModdle(options) {
      return new DmnModdle(options.moddleExtensions);
    }
    /**
     * Return the list of available view providers.
     *
     * @abstract
     *
     * @return {Array<ViewProvider>}
     */

  }, {
    key: "_getViewProviders",
    value: function _getViewProviders() {
      return [];
    }
  }]);

  return Manager;
}(); // helpers //////////////////////

/**
 * Ensure the passed argument is a proper unit (defaulting to px)
 */


export { Manager as default };

function ensureUnit(val) {
  return val + (isNumber(val) ? 'px' : '');
}

function checkDMNCompatibilityError(err, xml) {
  // check if we can indicate opening of old DMN 1.1 or DMN 1.2 diagrams
  if (err.message !== 'failed to parse document as <dmn:Definitions>') {
    return null;
  }

  var olderDMNVersion = xml.indexOf('"http://www.omg.org/spec/DMN/20151101/dmn.xsd"') !== -1 && '1.1' || xml.indexOf('"http://www.omg.org/spec/DMN/20180521/MODEL/"') !== -1 && '1.2';

  if (!olderDMNVersion) {
    return null;
  }

  err = new Error('unsupported DMN ' + olderDMNVersion + ' file detected; ' + 'only DMN 1.3 files can be opened');
  console.error('Cannot open what looks like a DMN ' + olderDMNVersion + ' diagram. ' + 'Please refer to https://bpmn.io/l/dmn-compatibility.html ' + 'to learn how to make the toolkit compatible with older DMN files', err);
  return err;
}

function checkValidationError(err) {
  // check if we can help the user by indicating wrong DMN 1.3 xml
  // (in case he or the exporting tool did not get that right)
  var pattern = /unparsable content <([^>]+)> detected([\s\S]*)$/,
      match = pattern.exec(err.message);

  if (!match) {
    return null;
  }

  err.message = 'unparsable content <' + match[1] + '> detected; ' + 'this may indicate an invalid DMN 1.3 diagram file' + match[2];
  return err;
}

function viewsEqual(a, b) {
  if (!isDefined(a)) {
    if (!isDefined(b)) {
      return true;
    } else {
      return false;
    }
  }

  if (!isDefined(b)) {
    return false;
  } // compare by element OR element ID equality


  return a.element === b.element || a.id === b.id;
}

function viewNameChanged(a, b) {
  return !a || !b || a.name !== b.name;
}

function safeExecute(viewer, method) {
  if (isFunction(viewer[method])) {
    viewer[method]();
  }
}
//# sourceMappingURL=Manager.js.map